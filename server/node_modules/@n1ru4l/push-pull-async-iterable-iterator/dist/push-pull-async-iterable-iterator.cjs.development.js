'use strict';

function createDeferred() {
  const d = {};
  d.promise = new Promise((resolve, reject) => {
    d.resolve = resolve;
    d.reject = reject;
  });
  return d;
}

const SYMBOL_FINISHED = /*#__PURE__*/Symbol();
const SYMBOL_NEW_VALUE = /*#__PURE__*/Symbol();
/**
 * makePushPullAsyncIterableIterator
 *
 * The iterable will publish values until return or throw is called.
 * Afterwards it is in the completed state and cannot be used for publishing any further values.
 * It will handle back-pressure and keep pushed values until they are consumed by a source.
 */

function makePushPullAsyncIterableIterator() {
  var _asyncIterableIterato, _asyncIterableIterato2;

  let isRunning = true;
  const values = [];
  let newValueD = createDeferred();
  let finishedD = createDeferred();

  const asyncIterableIterator = async function* PushPullAsyncIterableIterator() {
    while (true) {
      if (values.length > 0) {
        yield values.shift();
      } else {
        const result = await Promise.race([newValueD.promise, finishedD.promise]);

        if (result === SYMBOL_FINISHED) {
          break;
        }
      }
    }
  }();

  function pushValue(value) {
    if (isRunning === false) {
      // TODO: Should this throw?
      return;
    }

    values.push(value);
    newValueD.resolve(SYMBOL_NEW_VALUE);
    newValueD = createDeferred();
  } // We monkey patch the original generator for clean-up


  const originalReturn = (_asyncIterableIterato = asyncIterableIterator["return"]) == null ? void 0 : _asyncIterableIterato.bind(asyncIterableIterator);

  asyncIterableIterator["return"] = (...args) => {
    var _originalReturn;

    isRunning = false;
    finishedD.resolve(SYMBOL_FINISHED);
    return (_originalReturn = originalReturn == null ? void 0 : originalReturn(...args)) != null ? _originalReturn : Promise.resolve({
      done: true,
      value: undefined
    });
  };

  const originalThrow = (_asyncIterableIterato2 = asyncIterableIterator["throw"]) == null ? void 0 : _asyncIterableIterato2.bind(asyncIterableIterator);

  asyncIterableIterator["throw"] = (...args) => {
    var _originalThrow;

    isRunning = false;
    finishedD.resolve(SYMBOL_FINISHED);
    return (_originalThrow = originalThrow == null ? void 0 : originalThrow(...args)) != null ? _originalThrow : Promise.resolve({
      done: true,
      value: undefined
    });
  };

  return {
    pushValue,
    asyncIterableIterator
  };
}

const makeAsyncIterableIteratorFromSink = make => {
  const {
    pushValue,
    asyncIterableIterator
  } = makePushPullAsyncIterableIterator();

  let dispose = () => undefined;

  const sink = {
    next: value => {
      pushValue(value);
    },
    complete: () => {
      dispose();
      asyncIterableIterator.return == null ? void 0 : asyncIterableIterator.return();
    },
    error: err => {
      asyncIterableIterator.throw == null ? void 0 : asyncIterableIterator.throw(err);
    }
  };
  dispose = make(sink);
  return asyncIterableIterator;
};

function applyAsyncIterableIteratorToSink(asyncIterableIterator, sink) {
  const run = async () => {
    try {
      for await (const value of asyncIterableIterator) {
        sink.next(value);
      }

      sink.complete();
    } catch (err) {
      sink.error(err);
    }
  };

  run();
  return () => {
    asyncIterableIterator.return == null ? void 0 : asyncIterableIterator.return();
  };
}

function isAsyncIterable(input) {
  return typeof input === "object" && input !== null && ( // The AsyncGenerator check is for Safari on iOS which currently does not have
  // Symbol.asyncIterator implemented
  // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})
  input[Symbol.toStringTag] === "AsyncGenerator" || Symbol.asyncIterator && Symbol.asyncIterator in input);
}

exports.applyAsyncIterableIteratorToSink = applyAsyncIterableIteratorToSink;
exports.isAsyncIterable = isAsyncIterable;
exports.makeAsyncIterableIteratorFromSink = makeAsyncIterableIteratorFromSink;
exports.makePushPullAsyncIterableIterator = makePushPullAsyncIterableIterator;
//# sourceMappingURL=push-pull-async-iterable-iterator.cjs.development.js.map
